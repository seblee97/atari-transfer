#!/usr/bin/env python3
"""
Visualize transfer learning results from Atari RL experiments.

This script generates plots comparing transfer learning performance across
different algorithms, game pairs, and configurations.
"""

import os
import argparse
import csv
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict


def load_summary_csv(csv_path):
    """Load the summary CSV generated by analyze_results.py"""
    results = []

    with open(csv_path, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            results.append({
                'experiment_name': row['experiment_name'],
                'algorithm': row['algorithm'],
                'source_game': row['source_game'],
                'target_game': row['target_game'],
                'freeze_encoder': row['freeze_encoder'] == 'True',
                'reinit_head': row['reinit_head'] == 'True',
                'source_final_reward': float(row['source_final_reward']),
                'target_final_reward': float(row['target_final_reward']),
            })

    return results


def plot_algorithm_comparison(results, output_dir):
    """Plot comparison of algorithms across all transfer tasks."""

    # Group by algorithm
    by_algorithm = defaultdict(list)
    for result in results:
        by_algorithm[result['algorithm']].append(result['target_final_reward'])

    # Create bar plot
    algorithms = sorted(by_algorithm.keys())
    mean_rewards = [np.mean(by_algorithm[algo]) for algo in algorithms]
    std_rewards = [np.std(by_algorithm[algo]) for algo in algorithms]

    fig, ax = plt.subplots(figsize=(10, 6))
    x_pos = np.arange(len(algorithms))

    bars = ax.bar(x_pos, mean_rewards, yerr=std_rewards, capsize=5,
                   color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'][:len(algorithms)],
                   alpha=0.7)

    ax.set_xlabel('Algorithm', fontsize=12, fontweight='bold')
    ax.set_ylabel('Mean Target Game Reward', fontsize=12, fontweight='bold')
    ax.set_title('Transfer Learning Performance by Algorithm', fontsize=14, fontweight='bold')
    ax.set_xticks(x_pos)
    ax.set_xticklabels([algo.upper() for algo in algorithms])
    ax.grid(axis='y', alpha=0.3)

    # Add value labels on bars
    for i, (mean, std) in enumerate(zip(mean_rewards, std_rewards)):
        ax.text(i, mean + std + 0.5, f'{mean:.1f}', ha='center', va='bottom', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'algorithm_comparison.png'), dpi=300, bbox_inches='tight')
    print(f"Saved: {os.path.join(output_dir, 'algorithm_comparison.png')}")
    plt.close()


def plot_transfer_matrix(results, output_dir):
    """Plot transfer performance matrix (heatmap)."""

    # Get unique games
    games = sorted(set([r['source_game'] for r in results] + [r['target_game'] for r in results]))

    # Group by algorithm
    by_algorithm = defaultdict(list)
    for result in results:
        by_algorithm[result['algorithm']].append(result)

    # Create heatmap for each algorithm
    for algorithm, algo_results in by_algorithm.items():
        # Create matrix
        matrix = np.zeros((len(games), len(games)))
        counts = np.zeros((len(games), len(games)))

        for result in algo_results:
            source_idx = games.index(result['source_game'])
            target_idx = games.index(result['target_game'])
            matrix[source_idx, target_idx] += result['target_final_reward']
            counts[source_idx, target_idx] += 1

        # Average where we have multiple runs
        matrix = np.divide(matrix, counts, where=counts > 0)

        # Set diagonal to NaN (same game)
        for i in range(len(games)):
            matrix[i, i] = np.nan

        # Plot
        fig, ax = plt.subplots(figsize=(10, 8))
        im = ax.imshow(matrix, cmap='RdYlGn', aspect='auto')

        # Set ticks
        ax.set_xticks(np.arange(len(games)))
        ax.set_yticks(np.arange(len(games)))
        ax.set_xticklabels(games)
        ax.set_yticklabels(games)

        # Rotate x labels
        plt.setp(ax.get_xticklabels(), rotation=45, ha="right", rotation_mode="anchor")

        # Add colorbar
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Target Game Reward', rotation=270, labelpad=20, fontweight='bold')

        # Add text annotations
        for i in range(len(games)):
            for j in range(len(games)):
                if not np.isnan(matrix[i, j]):
                    text = ax.text(j, i, f'{matrix[i, j]:.1f}',
                                   ha="center", va="center", color="black", fontsize=9)

        ax.set_xlabel('Target Game', fontsize=12, fontweight='bold')
        ax.set_ylabel('Source Game', fontsize=12, fontweight='bold')
        ax.set_title(f'Transfer Learning Performance Matrix - {algorithm.upper()}',
                     fontsize=14, fontweight='bold')

        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, f'transfer_matrix_{algorithm}.png'),
                    dpi=300, bbox_inches='tight')
        print(f"Saved: {os.path.join(output_dir, f'transfer_matrix_{algorithm}.png')}")
        plt.close()


def plot_strategy_comparison(results, output_dir):
    """Compare transfer strategies (baseline vs freeze vs reinit)."""

    # Group by strategy
    by_strategy = defaultdict(list)

    for result in results:
        strategy = []
        if result['freeze_encoder']:
            strategy.append('freeze')
        if result['reinit_head']:
            strategy.append('reinit')
        strategy_str = '+'.join(strategy) if strategy else 'baseline'

        by_strategy[strategy_str].append(result['target_final_reward'])

    if len(by_strategy) <= 1:
        print("Not enough different strategies to compare.")
        return

    # Create bar plot
    strategies = sorted(by_strategy.keys())
    mean_rewards = [np.mean(by_strategy[strat]) for strat in strategies]
    std_rewards = [np.std(by_strategy[strat]) for strat in strategies]

    fig, ax = plt.subplots(figsize=(10, 6))
    x_pos = np.arange(len(strategies))

    bars = ax.bar(x_pos, mean_rewards, yerr=std_rewards, capsize=5,
                   color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'][:len(strategies)],
                   alpha=0.7)

    ax.set_xlabel('Transfer Strategy', fontsize=12, fontweight='bold')
    ax.set_ylabel('Mean Target Game Reward', fontsize=12, fontweight='bold')
    ax.set_title('Transfer Learning Performance by Strategy', fontsize=14, fontweight='bold')
    ax.set_xticks(x_pos)
    ax.set_xticklabels(strategies)
    ax.grid(axis='y', alpha=0.3)

    # Add value labels on bars
    for i, (mean, std) in enumerate(zip(mean_rewards, std_rewards)):
        ax.text(i, mean + std + 0.5, f'{mean:.1f}', ha='center', va='bottom', fontweight='bold')

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'strategy_comparison.png'), dpi=300, bbox_inches='tight')
    print(f"Saved: {os.path.join(output_dir, 'strategy_comparison.png')}")
    plt.close()


def plot_game_pair_ranking(results, output_dir, top_n=10):
    """Plot ranking of best and worst game pairs for transfer learning."""

    # Group by game pair
    by_pair = defaultdict(list)

    for result in results:
        pair = f"{result['source_game']}â†’{result['target_game']}"
        by_pair[pair].append(result['target_final_reward'])

    # Compute mean for each pair
    pair_means = {pair: np.mean(rewards) for pair, rewards in by_pair.items()}

    # Sort
    sorted_pairs = sorted(pair_means.items(), key=lambda x: x[1], reverse=True)

    # Plot top and bottom
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

    # Top performers
    top_pairs = sorted_pairs[:top_n]
    pairs_top = [pair for pair, _ in top_pairs]
    rewards_top = [reward for _, reward in top_pairs]

    ax1.barh(range(len(pairs_top)), rewards_top, color='#2ca02c', alpha=0.7)
    ax1.set_yticks(range(len(pairs_top)))
    ax1.set_yticklabels(pairs_top)
    ax1.set_xlabel('Mean Target Reward', fontsize=11, fontweight='bold')
    ax1.set_title(f'Top {top_n} Game Pairs for Transfer', fontsize=12, fontweight='bold')
    ax1.grid(axis='x', alpha=0.3)
    ax1.invert_yaxis()

    # Bottom performers
    bottom_pairs = sorted_pairs[-top_n:]
    pairs_bottom = [pair for pair, _ in bottom_pairs]
    rewards_bottom = [reward for _, reward in bottom_pairs]

    ax2.barh(range(len(pairs_bottom)), rewards_bottom, color='#d62728', alpha=0.7)
    ax2.set_yticks(range(len(pairs_bottom)))
    ax2.set_yticklabels(pairs_bottom)
    ax2.set_xlabel('Mean Target Reward', fontsize=11, fontweight='bold')
    ax2.set_title(f'Bottom {top_n} Game Pairs for Transfer', fontsize=12, fontweight='bold')
    ax2.grid(axis='x', alpha=0.3)
    ax2.invert_yaxis()

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'game_pair_ranking.png'), dpi=300, bbox_inches='tight')
    print(f"Saved: {os.path.join(output_dir, 'game_pair_ranking.png')}")
    plt.close()


def plot_transfer_benefit(results, output_dir):
    """Plot transfer learning benefit by comparing target performance vs from-scratch baseline."""

    # Group by algorithm and game
    by_algo_game = defaultdict(lambda: defaultdict(lambda: {'baseline': [], 'transfers': []}))

    for result in results:
        algorithm = result['algorithm']
        source_game = result['source_game']
        target_game = result['target_game']

        # Source game performance = from-scratch baseline for that game
        by_algo_game[algorithm][source_game]['baseline'].append(result['source_final_reward'])

        # Target game performance = transfer learning result
        by_algo_game[algorithm][target_game]['transfers'].append(result['target_final_reward'])

    # Create plot for each algorithm
    for algorithm in sorted(by_algo_game.keys()):
        games_data = by_algo_game[algorithm]

        games = []
        baselines = []
        transfer_avgs = []
        benefits = []

        for game in sorted(games_data.keys()):
            data = games_data[game]

            # Compute baseline (from-scratch)
            if data['baseline']:
                baseline_avg = np.mean(data['baseline'])
            else:
                continue  # Skip if no baseline

            # Compute transfer average
            if data['transfers']:
                transfer_avg = np.mean(data['transfers'])
            else:
                continue  # Skip if no transfers

            # Compute benefit
            benefit = transfer_avg - baseline_avg

            games.append(game)
            baselines.append(baseline_avg)
            transfer_avgs.append(transfer_avg)
            benefits.append(benefit)

        if not games:
            continue

        # Create grouped bar chart
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

        x = np.arange(len(games))
        width = 0.35

        # Left plot: Baseline vs Transfer
        bars1 = ax1.bar(x - width/2, baselines, width, label='From-Scratch Baseline',
                        color='#1f77b4', alpha=0.7)
        bars2 = ax1.bar(x + width/2, transfer_avgs, width, label='Transfer Average',
                        color='#ff7f0e', alpha=0.7)

        ax1.set_xlabel('Game', fontsize=12, fontweight='bold')
        ax1.set_ylabel('Mean Reward', fontsize=12, fontweight='bold')
        ax1.set_title(f'{algorithm.upper()}: Transfer vs From-Scratch', fontsize=14, fontweight='bold')
        ax1.set_xticks(x)
        ax1.set_xticklabels(games, rotation=45, ha='right')
        ax1.legend()
        ax1.grid(axis='y', alpha=0.3)
        ax1.axhline(y=0, color='black', linestyle='-', linewidth=0.5)

        # Right plot: Transfer benefit
        colors = ['#2ca02c' if b > 0 else '#d62728' for b in benefits]
        bars = ax2.bar(games, benefits, color=colors, alpha=0.7)

        ax2.set_xlabel('Game', fontsize=12, fontweight='bold')
        ax2.set_ylabel('Transfer Benefit (Reward Difference)', fontsize=12, fontweight='bold')
        ax2.set_title(f'{algorithm.upper()}: Transfer Learning Benefit', fontsize=14, fontweight='bold')
        ax2.set_xticklabels(games, rotation=45, ha='right')
        ax2.grid(axis='y', alpha=0.3)
        ax2.axhline(y=0, color='black', linestyle='-', linewidth=0.8)

        # Add value labels on benefit bars
        for i, (bar, benefit) in enumerate(zip(bars, benefits)):
            height = bar.get_height()
            ax2.text(bar.get_x() + bar.get_width()/2., height,
                    f'{benefit:+.1f}',
                    ha='center', va='bottom' if benefit > 0 else 'top',
                    fontweight='bold', fontsize=9)

        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, f'transfer_benefit_{algorithm}.png'),
                   dpi=300, bbox_inches='tight')
        print(f"Saved: {os.path.join(output_dir, f'transfer_benefit_{algorithm}.png')}")
        plt.close()


def main():
    parser = argparse.ArgumentParser(description="Visualize transfer learning experiment results")
    parser.add_argument('--summary', type=str, default='results_summary.csv',
                        help='Path to summary CSV file from analyze_results.py')
    parser.add_argument('--output-dir', type=str, default='plots',
                        help='Directory to save plots')

    args = parser.parse_args()

    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)

    # Load summary data
    print(f"Loading summary data from: {args.summary}")
    results = load_summary_csv(args.summary)

    if not results:
        print("No results found in summary file.")
        return

    print(f"Loaded {len(results)} experiment results")

    # Generate plots
    print("\nGenerating visualizations...")

    try:
        plot_algorithm_comparison(results, args.output_dir)
        plot_transfer_matrix(results, args.output_dir)
        plot_transfer_benefit(results, args.output_dir)
        plot_strategy_comparison(results, args.output_dir)
        plot_game_pair_ranking(results, args.output_dir)

        print("\n" + "="*80)
        print("VISUALIZATION COMPLETE")
        print("="*80)
        print(f"\nPlots saved to: {args.output_dir}/")
        print("\nGenerated plots:")
        print("  - algorithm_comparison.png: Compare algorithms")
        print("  - transfer_matrix_*.png: Heatmaps for each algorithm")
        print("  - transfer_benefit_*.png: Transfer vs from-scratch comparison")
        print("  - strategy_comparison.png: Compare transfer strategies")
        print("  - game_pair_ranking.png: Best/worst game pairs")

    except Exception as e:
        print(f"Error generating plots: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
